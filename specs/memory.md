# Memory Architecture: Supabase + Gemini

## 1. Supabase Cleanup (CRITICAL FIRST STEP)
> [!IMPORTANT]
> **Action Required**: Go to the Supabase Table Editor and **DELETE** the following unused tables to free up space and reduce noise:
> *   `companies`, `conversations`, `credit_purchases`, `generated_messages`
> *   `linkedin_accounts`, `linkedin_responses`, `messages` (Old version)
> *   `outreach_campaigns`, `outreach_targets`, `projects`, `refresh_tokens`
> *   `search_results`, `subscriptions`, `unipile_webhook...`, `upsell_attempts`, `user_onboarding`

## 2. Database Schema (Exhaustive)

### A. Core Data (The Source of Truth)
These tables store the raw JSON data. We map the JSON fields directly to `data` JSONB column.

*   **`public.angel_investors`**:
    *   `id` (UUID, Primary Key)
    *   `data` (JSONB) - Contains: `fullName`, `headline`, `email`, `linkedinUrl`, `about`, `addressWithCountry`, `profilePic`, `angel_score`, `validation_reasons_es/en`, `categories_general_es/en`, `categories_strong_es/en`, `stages_general_es/en`, `stages_strong_es/en`, `created_at`, `last_updated`.

*   **`public.investment_funds`**:
    *   `id` (UUID, Primary Key)
    *   `data` (JSONB) - Contains: `name`, `description`, `short_description`, `contact_email`, `phone_number`, `linkedin/value`, `website/value`, `location_identifiers` (Array), `category_keywords` (Stringified Array), `stage_keywords` (Stringified Array).

*   **`public.fund_employees`**:
    *   `id` (UUID, Primary Key)
    *   `data` (JSONB) - Contains: `fullName`, `headline`, `jobTitle`, `about`, `email`, `linkedinUrl`, `profilePic`, `addressWithCountry`, `companyLinkedin`, `companyName`, `companyWebsite`, `fund_name` (Foreign Key Logic), `relevancia_dentro_del_fondo`, `mira_pitch_decks`, `probabilidad_respuesta`, `score_combinado`, `razonamiento`.

### B. User Data (The Brain)
*   **`auth.users`**: Managed by Supabase Auth.
    *   `id` (UUID)
    *   `email` (String)

*   **`public.saved_investors`**:
    *   `user_id` (UUID)
    *   `investor_id` (UUID)
    *   `type` (String: 'angel' | 'fund' | 'employee')
    *   `created_at` (Timestamp)
    *   **Purpose**: Stores investors/employees saved by user (all algorithm results are auto-saved).

*   **`public.seen_investors`**:
    *   `user_id` (UUID)
    *   `investor_id` (UUID)
    *   `type` (String: 'angel' | 'fund')
    *   `created_at` (Timestamp)
    *   **Purpose**: Anti-duplication logic. Prevents showing previously displayed angels or funds in new search results. Applies to both angels and funds.

*   **`public.messages`**:
    *   `id` (UUID)
    *   `user_id` (UUID)
    *   `recipient_id` (UUID)
    *   `recipient_type` (String: 'angel' | 'employee')
    *   `recipient_name` (String) - For display purposes
    *   `company_context` (Text) - User's company description provided when drafting message
    *   `content` (Text) - The drafted message generated by Gemini
    *   `status` (String: 'draft' only for MVP)
    *   `created_at` (Timestamp)

## 3. Message Generation Logic (Inline Context)

> [!IMPORTANT]
> **Change from Original Plan**: We do NOT store user company context in the database. Instead, users provide their company description inline when drafting each message.

### Data Retrieval Logic
1.  **Company Context**: User types their company description directly in the message composition UI (see `chat.md` for UI spec)
2.  **Investor Data**:
    *   **If Angel**: Fetch *every single column* from the `public.angel_investors` row (`data` column).
    *   **If Employee**:
        *   Fetch *every single column* from the `public.fund_employees` row (`data` column).
        *   **JOIN**: Fetch *every single column* from the linked `public.investment_funds` row (using `fund_name` match).
3.  **Input to Gemini**:
    *   Construct a prompt containing:
        *   User's company description (from inline text input)
        *   Complete investor/employee/fund JSON data
    *   *Instruction*: "Use any and all data points to personalize the message. Do not ignore any column. Mine for 'Gold Nuggets' in `about`, `headline`, `description`, etc."

### Message Storage
*   The drafted message is saved to `public.messages` table along with:
    *   `company_context`: The user's company description (so they can see what they wrote)
    *   `content`: The AI-generated message
    *   `recipient_id`, `recipient_type`, `recipient_name`
    *   `status`: 'draft' (MVP only supports drafts, no sending functionality)

## 4. Fund-Employee Join Logic

### Linking Employees to Funds
*   **Join Key**: `fund_name` (in `fund_employees` table) matches `name` (in `investment_funds` table)
*   **Important**: Fund name matching should be **case-insensitive** to handle variations like "JME Ventures" vs "Jme Ventures"
*   **Implementation**: Use fuzzy or normalized matching (e.g., `LOWER(fund_name) = LOWER(name)`)

### Query Flow
1.  **Find Funds**: Run the Fund Matching algorithm to get relevant funds
2.  **Get Employees**: For each matched fund, query `SELECT * FROM fund_employees WHERE LOWER(fund_name) = LOWER(matched_fund.name)`
3.  **Rank Employees**: Sort by `score_combinado` (descending) and show all employees
4.  **Auto-Save**: All results from algorithm are automatically saved to `saved_investors` table
